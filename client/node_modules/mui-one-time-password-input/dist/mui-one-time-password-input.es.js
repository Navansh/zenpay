import { jsx as k } from "react/jsx-runtime";
import d from "react";
import { styled as Z } from "@mui/material/styles";
import v from "@mui/material/TextField";
import ee from "@mui/material/Box";
const te = Z(v)`
  input {
    text-align: center;
  }
`, ne = {
  TextFieldStyled: te
}, re = (n) => /* @__PURE__ */ k(ne.TextFieldStyled, { ...n }), y = {
  left: "ArrowLeft",
  right: "ArrowRight",
  backspace: "Backspace",
  home: "Home",
  end: "End"
};
function ae(n, l) {
  return n <= 0 ? [] : Array.from({ length: n }, l);
}
function le(n, l, u) {
  return n.map((c, g) => l === g ? u : c);
}
function M(n) {
  return n.join("");
}
function N(n, l) {
  return [...n, l];
}
function oe(n, l, u) {
  return n.reduce(
    (c, g, h) => {
      const { characters: x, restArrayMerged: p } = c;
      if (h < u)
        return {
          restArrayMerged: p,
          characters: N(x, g)
        };
      const [F, ...D] = p;
      return {
        restArrayMerged: D,
        characters: N(x, F || "")
      };
    },
    {
      restArrayMerged: l,
      characters: []
    }
  ).characters;
}
function se(n) {
  return n.split("");
}
function b(n) {
  const l = d.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  return d.useInsertionEffect(() => {
    l.current = n;
  }), d.useCallback((...u) => l.current?.(...u), []);
}
const ce = () => !0, he = d.forwardRef(
  (n, l) => {
    const {
      value: u = "",
      length: c = 4,
      autoFocus: g = !1,
      onChange: h,
      TextFieldsProps: x,
      onComplete: p,
      validateChar: F = ce,
      className: D,
      onBlur: K,
      ...j
    } = n, $ = d.useRef(u), A = b(p), m = b((e) => {
      const t = e.slice(0, c);
      return {
        isCompleted: t.length === c,
        finalValue: t
      };
    }), {
      onPaste: Y,
      onFocus: _,
      onKeyDown: H,
      className: L,
      placeholder: V,
      onBlur: W,
      ...q
    } = x || {};
    d.useEffect(() => {
      const { isCompleted: e, finalValue: t } = m(
        $.current
      );
      e && A(t);
    }, [c, A, m]);
    const i = ae(
      c,
      (e, t) => ({
        character: u[t] || "",
        inputRef: d.createRef()
      })
    ), O = (e) => i.findIndex(({ inputRef: t }) => t.current === e), T = () => i.map(({ character: e }) => e), R = (e, t) => {
      const r = le(
        T(),
        e,
        t
      );
      return M(r);
    }, z = (e) => {
      i[e]?.inputRef.current?.focus();
    }, o = (e) => {
      i[e]?.inputRef.current?.select();
    }, S = (e) => {
      e + 1 !== c && (i[e + 1].character ? o(e + 1) : z(e + 1));
    }, P = (e, t) => typeof F != "function" ? !0 : F(e, t), G = (e) => {
      const t = O(e.target);
      if (t === 0 && e.target.value.length > 1) {
        const { finalValue: I, isCompleted: w } = m(
          e.target.value
        );
        h?.(I), w && p?.(I), o(I.length - 1);
        return;
      }
      const r = e.target.value[0] || "";
      let s = r;
      s && !P(s, t) && (s = "");
      const a = R(t, s);
      h?.(a);
      const { isCompleted: C, finalValue: f } = m(a);
      C && p?.(f), s !== "" ? a.length - 1 < t ? o(a.length) : S(t) : r === "" && a.length <= t && o(t - 1);
    }, J = (e) => {
      e.preventDefault(), e.target.select(), _?.(e);
    }, Q = (e) => {
      const t = e.target, r = t.selectionStart, s = t.selectionEnd, a = O(t), C = r === 0 && s === 0;
      if (t.value === e.key)
        e.preventDefault(), S(a);
      else if (y.backspace === e.key) {
        if (!t.value)
          e.preventDefault(), o(a - 1);
        else if (C) {
          e.preventDefault();
          const f = R(a, "");
          h?.(f), f.length <= a && o(a - 1);
        }
      } else
        y.left === e.key ? (e.preventDefault(), o(a - 1)) : y.right === e.key ? (e.preventDefault(), o(a + 1)) : y.home === e.key ? (e.preventDefault(), o(0)) : y.end === e.key && (e.preventDefault(), o(i.length - 1));
      H?.(e);
    }, U = (e) => {
      e.preventDefault();
      const t = e.clipboardData.getData("text/plain"), r = e.target, s = i.findIndex(
        ({ character: B, inputRef: E }) => B === "" || E.current === r
      ), a = T(), C = oe(
        a,
        se(t),
        s
      ).map((B, E) => P(B, E) ? B : ""), f = M(C);
      h?.(f);
      const { isCompleted: I, finalValue: w } = m(f);
      I ? (p?.(w), o(c - 1)) : o(f.length), Y?.(e);
    }, X = (e) => {
      if (W?.(e), !i.some(({ inputRef: r }) => r.current === e.relatedTarget)) {
        const { isCompleted: r, finalValue: s } = m(u);
        K?.(s, r);
      }
    };
    return /* @__PURE__ */ k(
      ee,
      {
        display: "flex",
        gap: "20px",
        alignItems: "center",
        ref: l,
        className: `MuiOtpInput-Box ${D || ""}`,
        ...j,
        children: i.map(({ character: e, inputRef: t }, r) => /* @__PURE__ */ k(
          re,
          {
            autoFocus: g ? r === 0 : !1,
            autoComplete: "one-time-code",
            value: e,
            inputRef: t,
            className: `MuiOtpInput-TextField MuiOtpInput-TextField-${r + 1} ${L || ""}`,
            onPaste: U,
            onFocus: J,
            onChange: G,
            onKeyDown: Q,
            onBlur: X,
            placeholder: typeof V == "function" ? V(r) : V,
            ...q
          },
          r
        ))
      }
    );
  }
);
export {
  he as MuiOtpInput
};
